<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Jewel Christmas - Mobile Optimized</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: 'Helvetica Neue', Arial, sans-serif; 
            /* ç¦æ­¢æ‰‹æœºä¸Šçš„ä¸‹æ‹‰åˆ·æ–°å’Œæ»šåŠ¨ */
            touch-action: none;
            display: flex; justify-content: center; align-items: center; height: 100vh;
        }

        #canvas-wrapper {
            position: relative; width: 100%; height: 100%;
            background: #000;
        }

        #canvas-container { width: 100%; height: 100%; display: block; }
        
        /* æ‘„åƒå¤´å°çª—ï¼šä¼˜åŒ–æ ·å¼ */
        #video-container {
            position: absolute; top: 10px; right: 10px; width: 120px; height: 90px; z-index: 2;
            border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; overflow: hidden;
            transform: scaleX(-1); background: #000;
        }
        #input-video { 
            width: 100%; height: 100%; object-fit: cover; opacity: 0.5; 
            position: absolute; top: 0; left: 0;
        }
        #skeleton-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
        }

        #ui-layer {
            position: absolute; bottom: 20px; left: 20px; z-index: 3; pointer-events: none;
            color: #fff; text-shadow: 0 1px 3px rgba(0,0,0,0.9);
        }

        h1 {
            font-size: 1.5rem; margin: 0 0 5px 0; letter-spacing: 2px;
            background: linear-gradient(to right, #fff, #d4af37); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }

        #status-text { font-size: 1rem; color: #00ff88; font-weight: bold; margin-bottom: 10px; }
        
        .instructions {
            font-size: 0.8rem; color: #ccc; background: rgba(0,0,0,0.6); 
            padding: 10px; border-radius: 8px; border-left: 2px solid #d4af37;
            max-width: 200px; line-height: 1.5;
        }
        .highlight { color: #d4af37; font-weight: bold; }

        #upload-btn {
            pointer-events: auto; position: absolute; bottom: 20px; right: 20px;
            background: rgba(255, 215, 0, 0.2); border: 1px solid #d4af37;
            color: #d4af37; padding: 8px 16px; border-radius: 20px;
            font-size: 14px; backdrop-filter: blur(5px);
        }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #d4af37; font-size: 1.2rem; text-align: center;
            width: 80%; line-height: 1.5;
        }
        
        /* é”™è¯¯æç¤ºå±‚ */
        #error-overlay {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 999; color: white;
            flex-direction: column; justify-content: center; align-items: center; text-align: center;
            padding: 20px; box-sizing: border-box;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="error-overlay">
        <h3 style="color: #ff4444">æ‘„åƒå¤´æ— æ³•å¯åŠ¨</h3>
        <p>å¦‚æœæ˜¯æ‰‹æœºè®¿é—®ï¼Œè¯·ç¡®ä¿ä½¿ç”¨ HTTPS åè®®ï¼Œæˆ–è€…åœ¨ Chrome Flags ä¸­æ·»åŠ å®‰å…¨ç™½åå•ã€‚</p>
        <p style="font-size: 0.8em; color: #888">é”™è¯¯: <span id="error-msg"></span></p>
    </div>

    <div id="canvas-wrapper">
        <div id="canvas-container"></div>
        
        <div id="video-container">
            <video id="input-video" autoplay playsinline muted></video>
            <canvas id="skeleton-canvas"></canvas>
        </div>

        <div id="ui-layer">
            <h1>Jewel Tree</h1>
            <div id="status-text">åˆå§‹åŒ–ä¸­...</div>
            <div class="instructions">
                âœŠ æ¡æ‹³: èšåˆ<br/>
                ğŸ– å¼ å¼€: æ•£å¼€<br/>
                ğŸ‘‹ æŒ¥æ‰‹: æ—‹è½¬<br/>
                ğŸ‘Œ æåˆ: æŠ“ç…§ç‰‡
            </div>
        </div>
        
        <button id="upload-btn" onclick="document.getElementById('file-input').click()">+ ç…§ç‰‡</button>
        <input type="file" id="file-input" multiple accept="image/*" style="display:none">
        
        <div id="loading">æ­£åœ¨åŠ è½½è§†è§‰å¼•æ“...<br><span style="font-size:0.8rem;color:#888">(é¦–æ¬¡åŠ è½½å¯èƒ½éœ€è¦10ç§’)</span></div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0';

        // --- 1. ç§»åŠ¨ç«¯æ£€æµ‹ä¸é…ç½®é™çº§ ---
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        const CONFIG = isMobile ? {
            // ç§»åŠ¨ç«¯ï¼šå¤§å¹…å‡å°‘ç²’å­æ•°é‡
            goldCount: 150, silverCount: 150, gemCount: 80, emeraldCount: 80, dustCount: 300,
            treeHeight: 60, maxRadius: 25,
            bloomRes: 0.25, // é™ä½è¾‰å…‰åˆ†è¾¨ç‡ (1/4)
            pixelRatio: 1.0 // å¼ºåˆ¶ 1.0 åƒç´ æ¯”
        } : {
            // æ¡Œé¢ç«¯ï¼šé«˜ç”»è´¨
            goldCount: 600, silverCount: 600, gemCount: 400, emeraldCount: 400, dustCount: 1200,
            treeHeight: 75, maxRadius: 30,
            bloomRes: 1.0,
            pixelRatio: Math.min(window.devicePixelRatio, 1.5)
        };

        const STATE = { TREE: 'tree', SCATTER: 'scatter', ZOOM: 'zoom' };
        let currentState = STATE.TREE;
        let mainGroup = new THREE.Group();
        let scene, camera, renderer, composer;
        
        // æ•°æ®å®¹å™¨
        let logicData = { gold: [], silver: [], gem: [], emerald: [], dust: [] };
        let photoMeshes = [];
        let zoomTargetIndex = -1;
        let time = 0;
        
        // æ‰‹åŠ¿å˜é‡
        let handPos = { x: 0, y: 0 }, lastHandPos = { x: 0, y: 0 };
        let isHandPresent = false;
        let rotationVelocity = { x: 0, y: 0 };

        // --- 2. åˆå§‹åŒ– Three.js ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 0, isMobile ? 130 : 110); // æ‰‹æœºç¦»è¿œä¸€ç‚¹

            renderer = new THREE.WebGLRenderer({ antialias: !isMobile, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(CONFIG.pixelRatio);
            container.appendChild(renderer.domElement);

            // ç®€åŒ–ç¯å…‰
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const dirLight = new THREE.DirectionalLight(0xffddaa, 2);
            dirLight.position.set(20, 50, 20);
            scene.add(dirLight);

            // åå¤„ç† (Bloom) - æ‰‹æœºç«¯å¤§å¹…ä¼˜åŒ–åˆ†è¾¨ç‡
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth * CONFIG.bloomRes, window.innerHeight * CONFIG.bloomRes), 
                1.5, 0.4, 0.85
            );
            bloomPass.threshold = 0.3;
            bloomPass.strength = isMobile ? 0.8 : 0.6; // æ‰‹æœºç«¯ç¨å¾®äº®ä¸€ç‚¹å¼¥è¡¥æè´¨ç¼ºå¤±
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            createOptimizedContent();
            window.addEventListener('resize', onResize);
        }

        // --- 3. åˆ›å»ºä¼˜åŒ–çš„æè´¨ä¸ç‰©ä½“ ---
        function createOptimizedContent() {
            // æè´¨é™çº§ï¼šæ‰‹æœºä½¿ç”¨ StandardMaterial ä»£æ›¿ PhysicalMaterial (å»é™¤äº†ç‰©ç†é€å…‰è®¡ç®—)
            const commonEnv = { roughness: 0.2, metalness: 0.9 };
            
            const goldMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, ...commonEnv, emissive: 0xaa5500, emissiveIntensity: 0.2 });
            const silverMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, ...commonEnv });
            
            // å®çŸ³æè´¨ï¼šæ‰‹æœºä¸Šå–æ¶ˆé€å…‰ï¼Œæ”¹ç”¨é«˜åå…‰å’Œè‡ªå‘å…‰æ¨¡æ‹Ÿ
            const gemMat = isMobile ? 
                new THREE.MeshStandardMaterial({ color: 0xff0044, roughness: 0.1, metalness: 0.8, emissive: 0x440011, emissiveIntensity: 0.4 }) :
                new THREE.MeshPhysicalMaterial({ color: 0xff0044, metalness: 0.1, roughness: 0, transmission: 0.6, thickness: 1.0 });

            const emeraldMat = isMobile ?
                new THREE.MeshStandardMaterial({ color: 0x00aa55, roughness: 0.1, metalness: 0.8, emissive: 0x002211, emissiveIntensity: 0.4 }) :
                new THREE.MeshPhysicalMaterial({ color: 0x00aa55, metalness: 0.2, roughness: 0.1, transmission: 0.5, thickness: 1.5 });

            // å‡ ä½•ä½“å¤ç”¨
            const sphereGeo = new THREE.SphereGeometry(0.7, 12, 12); // å‡å°‘é¢æ•°
            const boxGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const diamondGeo = new THREE.OctahedronGeometry(0.8, 0);

            createInstancedMesh(sphereGeo, goldMat, CONFIG.goldCount, logicData.gold);
            createInstancedMesh(boxGeo, silverMat, CONFIG.silverCount, logicData.silver);
            createInstancedMesh(diamondGeo, gemMat, CONFIG.gemCount, logicData.gem);
            createInstancedMesh(new THREE.ConeGeometry(0.5, 1.2, 6), emeraldMat, CONFIG.emeraldCount, logicData.emerald);

            // ç®€å•çš„ç²’å­å°˜åŸƒ
            const dustGeo = new THREE.BufferGeometry();
            const dustPos = new Float32Array(CONFIG.dustCount * 3);
            for(let i=0; i<CONFIG.dustCount; i++) {
                // é€»è¾‘æ•°æ®åˆå§‹åŒ– (å¤ç”¨åŸé€»è¾‘)
                const item = generateItemData();
                logicData.dust.push(item);
                dustPos[i*3] = item.currentPos.x;
                dustPos[i*3+1] = item.currentPos.y;
                dustPos[i*3+2] = item.currentPos.z;
            }
            dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPos, 3));
            const dustMat = new THREE.PointsMaterial({ color: 0xffffee, size: 0.8, transparent: true, opacity: 0.6, sizeAttenuation: true });
            const dustSystem = new THREE.Points(dustGeo, dustMat);
            dustSystem.userData = { isDust: true }; // æ ‡è®°
            mainGroup.add(dustSystem);

            scene.add(mainGroup);
        }

        function createInstancedMesh(geo, mat, count, dataArray) {
            const mesh = new THREE.InstancedMesh(geo, mat, count);
            mainGroup.add(mesh);
            const dummy = new THREE.Object3D();
            
            for (let i = 0; i < count; i++) {
                const data = generateItemData();
                dataArray.push(data);
                dummy.position.copy(data.currentPos);
                dummy.scale.setScalar(data.scale);
                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
            }
            mesh.instanceMatrix.needsUpdate = true;
            return mesh;
        }

        function generateItemData() {
            const h = Math.random() * CONFIG.treeHeight - CONFIG.treeHeight/2;
            const normH = (h + CONFIG.treeHeight/2) / CONFIG.treeHeight;
            const rMax = CONFIG.maxRadius * (1 - normH);
            const r = Math.sqrt(Math.random()) * rMax;
            const theta = Math.random() * Math.PI * 2;
            
            return {
                treePos: new THREE.Vector3(r * Math.cos(theta), h, r * Math.sin(theta)),
                scatterPos: new THREE.Vector3((Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80),
                currentPos: new THREE.Vector3(r * Math.cos(theta), h, r * Math.sin(theta)),
                scale: 0.5 + Math.random() * 0.8,
                rotation: new THREE.Euler(Math.random()*3, Math.random()*3, 0)
            };
        }

        // --- 4. åŠ¨ç”»å¾ªç¯ ---
        const dummy = new THREE.Object3D();
        
        function animate() {
            requestAnimationFrame(animate);
            time += 0.015;

            // ç‰©ç†æƒ¯æ€§
            if (currentState === STATE.SCATTER) {
                if (isHandPresent) {
                    const dx = handPos.x - lastHandPos.x;
                    const dy = handPos.y - lastHandPos.y;
                    if (Math.abs(dx) > 0.002) rotationVelocity.y += dx * 0.2;
                    if (Math.abs(dy) > 0.002) rotationVelocity.x += dy * 0.1;
                    lastHandPos.x = handPos.x;
                    lastHandPos.y = handPos.y;
                }
                rotationVelocity.x *= 0.92;
                rotationVelocity.y *= 0.95;
                mainGroup.rotation.y += rotationVelocity.y;
                mainGroup.rotation.x += rotationVelocity.x;
                mainGroup.rotation.x *= 0.98; // å›æ­£Xè½´
            } else if (currentState === STATE.TREE) {
                mainGroup.rotation.y += 0.005;
                mainGroup.rotation.x *= 0.9;
            }

            // æ›´æ–° Instance Mesh
            updateGroup(logicData.gold, mainGroup.children[0]);
            updateGroup(logicData.silver, mainGroup.children[1]);
            updateGroup(logicData.gem, mainGroup.children[2]);
            updateGroup(logicData.emerald, mainGroup.children[3]);
            
            // æ›´æ–°å°˜åŸƒ
            const dustSys = mainGroup.children.find(c => c.userData.isDust);
            if(dustSys) {
                const positions = dustSys.geometry.attributes.position.array;
                logicData.dust.forEach((item, i) => {
                    let target = currentState === STATE.TREE ? item.treePos : item.scatterPos;
                    if(currentState !== STATE.TREE) item.currentPos.lerp(target, 0.05);
                    else {
                        // æ ‘çŠ¶æ€ä¸‹å°˜åŸƒç¼“ç¼“ä¸Šå‡
                        item.currentPos.lerp(item.treePos, 0.05);
                        item.currentPos.y += 0.05;
                        if(item.currentPos.y > CONFIG.treeHeight/2) item.currentPos.y = -CONFIG.treeHeight/2;
                    }
                    positions[i*3] = item.currentPos.x;
                    positions[i*3+1] = item.currentPos.y;
                    positions[i*3+2] = item.currentPos.z;
                });
                dustSys.geometry.attributes.position.needsUpdate = true;
            }

            updatePhotos();
            composer.render();
        }

        function updateGroup(dataArray, mesh) {
            if(!mesh || !mesh.isInstancedMesh) return;
            for (let i = 0; i < dataArray.length; i++) {
                const item = dataArray[i];
                let target = currentState === STATE.TREE ? item.treePos : item.scatterPos;
                if(currentState === STATE.ZOOM) target = item.scatterPos;

                if (currentState !== STATE.TREE) {
                    item.currentPos.lerp(target, 0.08); // æ•£å¼€å¿«ä¸€ç‚¹
                } else {
                    item.currentPos.lerp(target, 0.04); // èšåˆæ…¢ä¸€ç‚¹
                }

                item.rotation.x += 0.01;
                item.rotation.y += 0.01;

                dummy.position.copy(item.currentPos);
                dummy.rotation.copy(item.rotation);
                
                let s = item.scale;
                if(currentState === STATE.ZOOM) s *= 0.5; // èšç„¦æ—¶èƒŒæ™¯å˜å°
                dummy.scale.setScalar(s);
                
                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
            }
            mesh.instanceMatrix.needsUpdate = true;
        }

        function updatePhotos() {
            photoMeshes.forEach((mesh, idx) => {
                let targetPos, targetScale = 2.0; 
                
                if (currentState === STATE.ZOOM && idx === zoomTargetIndex) {
                    // é£åˆ°å±å¹•æ­£å‰æ–¹
                    const vector = new THREE.Vector3(0, 0, 80);
                    vector.applyQuaternion(camera.quaternion); // å¹¶ä¸æ˜¯å¾ˆå‡†ï¼Œç®€åŒ–å¤„ç†ï¼š
                    // ç›´æ¥è½¬åˆ°ç›¸æœºç©ºé—´çš„åæ ‡
                    targetPos = camera.position.clone().add(new THREE.Vector3(0, 0, -30)); 
                    // è½¬å›æœ¬åœ°åæ ‡ç³»æœ‰ç‚¹éº»çƒ¦ï¼Œè¿™é‡Œç®€åŒ–ï¼šè®©ç…§ç‰‡ç›´æ¥è·Ÿç€ç›¸æœº
                    mesh.position.lerp(targetPos, 0.1);
                    mesh.lookAt(camera.position);
                    targetScale = 5.0;
                } else {
                    let t = currentState === STATE.TREE ? mesh.userData.treePos : mesh.userData.scatterPos;
                    // éœ€è¦æŠŠä¸–ç•Œåæ ‡è½¬ä¸º Group æœ¬åœ°åæ ‡çš„é€»è¾‘åœ¨è¿™é‡Œçœç•¥äº†ï¼Œç›´æ¥ç§»åŠ¨ mesh
                    // ä¿®æ­£ï¼šç…§ç‰‡ç›´æ¥åŠ åœ¨ mainGroup é‡Œï¼Œæ‰€ä»¥ t å°±æ˜¯æœ¬åœ°åæ ‡
                    mesh.position.lerp(t, 0.1);
                    mesh.lookAt(camera.position);
                    targetScale = (currentState === STATE.SCATTER) ? 4.0 : 2.0;
                }
                mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
            });
        }

        // --- 5. æ‰‹åŠ¿è¯†åˆ« (å¸¦é”™è¯¯å¤„ç†) ---
        async function setupMediaPipe() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
                const handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU" // æ‰‹æœºå¦‚æœå¡é¡¿å¯æ”¹ä¸º "CPU"
                    },
                    runningMode: "VIDEO", numHands: 1
                });

                const video = document.getElementById("input-video");
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: "user", width: 320, height: 240 } // é™ä½æ‘„åƒå¤´åˆ†è¾¨ç‡ä»¥æå‡é€Ÿåº¦
                });
                
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('status-text').innerText = "ç³»ç»Ÿå°±ç»ª";
                    predictWebcam(handLandmarker, video);
                });

            } catch (err) {
                console.error(err);
                document.getElementById('loading').style.display = 'none';
                const errOverlay = document.getElementById('error-overlay');
                const errMsg = document.getElementById('error-msg');
                errOverlay.style.display = 'flex';
                errMsg.innerText = err.name + ": " + err.message;
            }
        }

        let lastVideoTime = -1;
        let frameCounter = 0;
        
        async function predictWebcam(handLandmarker, video) {
            // æ‰‹æœºç«¯é™é¢‘æ£€æµ‹ï¼šæ¯2å¸§æ£€æµ‹ä¸€æ¬¡ï¼ŒèŠ‚çœCPUç»™æ¸²æŸ“
            frameCounter++;
            if(isMobile && frameCounter % 2 !== 0) {
                requestAnimationFrame(() => predictWebcam(handLandmarker, video));
                return;
            }

            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const startTime = performance.now();
                const result = handLandmarker.detectForVideo(video, startTime);
                
                const canvas = document.getElementById('skeleton-canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (result.landmarks && result.landmarks.length > 0) {
                    const landmarks = result.landmarks[0];
                    isHandPresent = true;
                    drawSkeleton(ctx, landmarks, canvas.width, canvas.height);
                    handleGesture(landmarks);
                } else {
                    isHandPresent = false;
                }
            }
            requestAnimationFrame(() => predictWebcam(handLandmarker, video));
        }

        function handleGesture(landmarks) {
            // è®¡ç®—æ‰‹å¿ƒä½ç½®ç”¨äºæ—‹è½¬
            const palmX = 1 - landmarks[0].x; // é•œåƒ
            const palmY = landmarks[0].y;
            handPos.x = handPos.x * 0.7 + palmX * 0.3;
            handPos.y = handPos.y * 0.7 + palmY * 0.3;

            // 1. æ¡æ‹³æ£€æµ‹ï¼šæ£€æµ‹æŒ‡å°–åˆ°æ‰‹æŒæ ¹éƒ¨çš„è·ç¦»
            let bentFingers = 0;
            [8, 12, 16, 20].forEach((tipIdx, i) => {
                const tip = landmarks[tipIdx];
                const base = landmarks[0]; // æ‰‹è…•
                const pip = landmarks[[6, 10, 14, 18][i]]; // æŒ‡å…³èŠ‚
                
                const dTip = Math.hypot(tip.x - base.x, tip.y - base.y);
                const dPip = Math.hypot(pip.x - base.x, pip.y - base.y);
                // å¦‚æœæŒ‡å°–æ¯”æŒ‡å…³èŠ‚æ›´é è¿‘æ‰‹è…•ï¼Œè¯´æ˜å¼¯æ›²äº†
                if (dTip < dPip * 1.1) bentFingers++;
            });

            // 2. æåˆæ£€æµ‹
            const dPinch = Math.hypot(landmarks[4].x - landmarks[8].x, landmarks[4].y - landmarks[8].y);
            const isPinch = dPinch < 0.08; 

            // çŠ¶æ€æœº
            const status = document.getElementById('status-text');

            if (isPinch && photoMeshes.length > 0) {
                // æåˆä¸”æœ‰ç…§ç‰‡
                if(currentState !== STATE.ZOOM) {
                    currentState = STATE.ZOOM;
                    status.innerHTML = "ğŸ“¸ æŠ“å–ç…§ç‰‡";
                    // ç®€å•é€‰å–ç¬¬ä¸€å¼ ï¼Œæˆ–è€…éšæœº
                    if(zoomTargetIndex === -1) zoomTargetIndex = Math.floor(Math.random() * photoMeshes.length);
                }
            } else if (bentFingers >= 3) {
                // æ¡æ‹³
                currentState = STATE.TREE;
                status.innerHTML = "ğŸ„ èšåˆ";
                zoomTargetIndex = -1;
            } else {
                // å¼ å¼€
                if(currentState === STATE.TREE || currentState === STATE.ZOOM && !isPinch) {
                     currentState = STATE.SCATTER;
                     status.innerHTML = "âœ¨ æ•£å¼€";
                }
            }
        }

        function drawSkeleton(ctx, landmarks, w, h) {
            ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2;
            ctx.beginPath();
            // ç®€å•ç”»å‡ æ ¹çº¿ç¤ºæ„
            const pairs = [[0,5],[5,8],[0,9],[9,12],[0,13],[13,16],[0,17],[17,20]];
            pairs.forEach(p => {
                ctx.moveTo(landmarks[p[0]].x * w, landmarks[p[0]].y * h);
                ctx.lineTo(landmarks[p[1]].x * w, landmarks[p[1]].y * h);
            });
            ctx.stroke();
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // æ·»åŠ ç…§ç‰‡
        document.getElementById('file-input').addEventListener('change', (e) => {
            if(!e.target.files.length) return;
            Array.from(e.target.files).forEach(file => {
                const reader = new FileReader();
                reader.onload = (evt) => {
                    const img = new Image();
                    img.src = evt.target.result;
                    img.onload = () => {
                        const tex = new THREE.Texture(img);
                        tex.needsUpdate = true;
                        tex.colorSpace = THREE.SRGBColorSpace;
                        const ratio = img.width / img.height;
                        const w = ratio >= 1 ? 5 : 5 * ratio;
                        const h = ratio >= 1 ? 5 / ratio : 5;
                        
                        const geo = new THREE.PlaneGeometry(w, h);
                        const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
                        const mesh = new THREE.Mesh(geo, mat);
                        
                        // éšæœºä½ç½®
                        const item = generateItemData();
                        mesh.userData = item; // ç»‘å®šä½ç½®æ•°æ®
                        mesh.position.copy(item.treePos);
                        
                        photoMeshes.push(mesh);
                        mainGroup.add(mesh);
                        alert("ç…§ç‰‡å·²æ·»åŠ ï¼è¯•è¯•æåˆæ‰‹æŒ‡æŠ“å–å®ƒã€‚");
                    };
                };
                reader.readAsDataURL(file);
            });
        });

        initThree();
        animate();
        setupMediaPipe();
    </script>
</body>
</html>
