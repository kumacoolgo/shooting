<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>AR 忍者：畅玩版</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            height: 100dvh; width: 100vw; touch-action: none; 
            font-family: 'Arial', sans-serif; user-select: none;
        }
        #input_video { 
            position: absolute; width: 100%; height: 100%; 
            object-fit: cover; transform: scaleX(-1); 
            z-index: 0; opacity: 0.8; filter: saturate(1.2);
        }
        #output_canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; 
        }
        #hud { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 2; pointer-events: none; 
        }
        .score-board { 
            position: absolute; top: 20px; left: 20px; 
            color: #fff; font-size: 24px; font-weight: 900; 
            text-shadow: 2px 2px 0 #000, -1px -1px 0 #f90; 
        }
        .lives {
            position: absolute; top: 20px; right: 20px;
            color: #ff3333; font-size: 24px; font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }
        #overlay { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.85); z-index: 999; display: flex; 
            flex-direction: column; justify-content: center; align-items: center; 
            color: white; transition: opacity 0.3s; 
        }
        #start-btn, #restart-btn { 
            padding: 15px 50px; background: linear-gradient(to bottom, #ffcc00, #ff9900); 
            color: #000; font-size: 22px; font-weight: bold; border: none; border-radius: 8px; 
            cursor: pointer; box-shadow: 0 5px #cc6600; margin-top: 20px;
        }
        h1 { margin: 0; font-style: italic; color: #ffcc00; text-shadow: 2px 2px #ff0000; font-size: 40px; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="overlay">
        <h1 id="overlay-title">AR 水果忍者</h1>
        <div id="loading-text" style="margin-top: 20px;">正在加载 AI...</div>
        <button id="start-btn" style="display:none;">开始游戏 (30条命)</button>
        <div id="game-over-content" style="display:none; text-align: center;">
            <h2 style="color:#fff">游戏结束</h2>
            <p style="font-size: 24px;">最终得分: <span id="final-score">0</span></p>
            <button id="restart-btn">再来一局</button>
        </div>
    </div>

    <video id="input_video" playsinline webkit-playsinline></video>
    <canvas id="output_canvas"></canvas>
    
    <div id="hud">
        <div class="score-board">SCORE: <span id="score">0</span></div>
        <div class="lives" id="lives">HP: 30</div>
    </div>

<script>
// ================= 配置调整区域 =================
const config = {
    // 【修改】减小重力，让水果飞得更慢、更飘逸
    gravity: -0.005,       
    
    // 出现频率
    spawnRate: 0.02,       
    
    // 切割灵敏度
    swipeSpeedThreshold: 12, 
    
    // 【修改】生命值改为 30
    maxLives: 30
};

let state = {
    score: 0,
    lives: config.maxLives,
    isPlaying: false,
    isGameOver: false,
    fingerPos: new THREE.Vector2(), 
    lastFingerPos: new THREE.Vector2(), 
    fingerVelocity: 0,
    hasHand: false,
    trailPoints: [] 
};

// DOM
const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('start-btn');
const restartBtn = document.getElementById('restart-btn');
const loadingText = document.getElementById('loading-text');

// ================= Three.js 基础 =================
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.z = 18; // 相机稍微拉远一点，视野更大

const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('output_canvas'), alpha: true, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(5, 10, 7);
scene.add(dirLight);

// ================= 水果系统 =================
let fruits = [];
let slicedParts = [];

const fruitTypes = [
    { color: 0xff9900, size: 0.9, score: 10 }, // 橙
    { color: 0xff3333, size: 0.8, score: 15 }, // 苹果
    { color: 0xffff00, size: 1.0, score: 20 }, // 柠檬
    { color: 0xcc00cc, size: 0.85, score: 30 }, // 李子
];

const wholeGeo = new THREE.SphereGeometry(1, 16, 16);
const halfGeo = new THREE.SphereGeometry(1, 16, 8, 0, Math.PI); 

class Fruit {
    constructor() {
        this.type = fruitTypes[0];
        this.mesh = new THREE.Mesh(wholeGeo, new THREE.MeshPhongMaterial({ color: 0xffffff, shininess: 50 }));
        this.reset();
        scene.add(this.mesh);
    }

    reset() {
        this.active = true;
        this.isSliced = false;
        this.mesh.visible = true;
        this.type = fruitTypes[Math.floor(Math.random() * fruitTypes.length)];
        this.mesh.material.color.setHex(this.type.color);
        this.mesh.scale.setScalar(this.type.size);
        
        // 【修改】初始位置：屏幕下方更深处 (-12)
        const startX = (Math.random() - 0.5) * 14;
        this.mesh.position.set(startX, -12, 0); 
        
        // 【核心修改】初始速度优化：
        // 1. Y轴速度大幅提升 (0.35 - 0.48)，确保飞到屏幕上半部分
        // 2. 结合低重力，形成高抛物线
        this.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 0.25, // X轴水平漂移
            0.35 + Math.random() * 0.13,  // Y轴向上冲击力
            0
        );
        
        this.rotationSpeed = new THREE.Vector3(
            Math.random()*0.1, Math.random()*0.1, Math.random()*0.1
        );
    }

    update() {
        if (!this.active) return;

        // 物理更新
        this.velocity.y += config.gravity;
        this.mesh.position.add(this.velocity);
        this.mesh.rotation.x += this.rotationSpeed.x;
        this.mesh.rotation.y += this.rotationSpeed.y;

        // 漏掉检测：掉出屏幕下方很远才算
        if (this.mesh.position.y < -15 && !this.isSliced) {
            this.active = false;
            this.mesh.visible = false;
            loseLife();
        }
    }

    slice(cutDirection) {
        if (this.isSliced) return;
        this.isSliced = true;
        this.mesh.visible = false;
        this.active = false;
        
        playAudio('slice');
        state.score += this.type.score;
        scoreEl.innerText = state.score;
        this.spawnHalves(cutDirection);
    }

    spawnHalves(cutDirection) {
        const mat = this.mesh.material;
        const normal = new THREE.Vector2(-cutDirection.y, cutDirection.x);
        for (let i = -1; i <= 1; i += 2) {
            const half = new THREE.Mesh(halfGeo, mat);
            half.scale.setScalar(this.type.size);
            half.position.copy(this.mesh.position);
            half.lookAt(this.mesh.position.clone().add(new THREE.Vector3(normal.x, normal.y, 0)));
            if (i === 1) half.rotateX(Math.PI);
            
            // 碎片受重力影响更大，掉得快一点
            half.userData.velocity = this.velocity.clone().add(
                new THREE.Vector3(normal.x * i * 0.1, normal.y * i * 0.1, Math.random()*0.2)
            );
            half.userData.rotSpeed = new THREE.Vector3(Math.random()*0.2, Math.random(), 0);
            scene.add(half);
            slicedParts.push(half);
        }
    }
}

function updateFruits() {
    if (Math.random() < config.spawnRate) {
        let fruit = fruits.find(f => !f.active);
        if (!fruit) {
            fruit = new Fruit();
            fruits.push(fruit);
        } else {
            fruit.reset();
        }
    }
    fruits.forEach(f => f.update());
    for (let i = slicedParts.length - 1; i >= 0; i--) {
        const part = slicedParts[i];
        part.userData.velocity.y += config.gravity * 1.5;
        part.position.add(part.userData.velocity);
        part.rotation.x += part.userData.rotSpeed.x;
        if (part.position.y < -18) {
            scene.remove(part);
            slicedParts.splice(i, 1);
        }
    }
}

function loseLife() {
    if (state.isGameOver) return;
    state.lives--;
    livesEl.innerText = "HP: " + state.lives;
    livesEl.style.color = state.lives < 10 ? '#ff0000' : '#ff3333';
    
    if (state.lives <= 0) {
        gameOver();
    }
}

function gameOver() {
    state.isPlaying = false;
    state.isGameOver = true;
    document.getElementById('final-score').innerText = state.score;
    startBtn.style.display = 'none';
    document.getElementById('game-over-content').style.display = 'block';
    document.getElementById('overlay-title').innerText = "";
    overlay.style.display = 'flex';
    overlay.style.opacity = 1;
}

function resetGame() {
    state.score = 0;
    state.lives = config.maxLives;
    state.isGameOver = false;
    scoreEl.innerText = "0";
    livesEl.innerText = "HP: " + state.lives;
    fruits.forEach(f => { f.active = false; f.mesh.visible = false; });
    slicedParts.forEach(p => scene.remove(p));
    slicedParts = [];
}

// ================= 刀光与输入 =================
const trailMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 3, transparent: true, opacity: 0.8 });
const trailGeo = new THREE.BufferGeometry();
const trailLine = new THREE.Line(trailGeo, trailMat);
scene.add(trailLine);

function updateInputAndCheckSlice() {
    if (!state.hasHand) {
        state.trailPoints = [];
        trailLine.visible = false;
        return;
    }

    const dx = state.fingerPos.x - state.lastFingerPos.x;
    const dy = state.fingerPos.y - state.lastFingerPos.y;
    state.fingerVelocity = Math.sqrt(dx*dx + dy*dy);

    const vec = new THREE.Vector3(
        (state.fingerPos.x / window.innerWidth) * 2 - 1,
        -(state.fingerPos.y / window.innerHeight) * 2 + 1,
        0.5
    );
    vec.unproject(camera);
    const dir = vec.sub(camera.position).normalize();
    const distance = -camera.position.z / dir.z;
    const pos3D = camera.position.clone().add(dir.multiplyScalar(distance));

    state.trailPoints.unshift(pos3D);
    if (state.trailPoints.length > 8) state.trailPoints.pop();

    if (state.trailPoints.length > 1) {
        trailLine.geometry.setFromPoints(state.trailPoints);
        trailLine.geometry.attributes.position.needsUpdate = true;
        trailLine.visible = true;
    }

    if (state.fingerVelocity > config.swipeSpeedThreshold) {
        const cutDir = new THREE.Vector2(dx, dy).normalize();
        fruits.forEach(fruit => {
            if (!fruit.active || fruit.isSliced) return;
            const screenPos = fruit.mesh.position.clone().project(camera);
            const fruitX = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
            const fruitY = (-(screenPos.y * 0.5) + 0.5) * window.innerHeight;
            
            // 判定半径放宽一点点
            const hitRadius = fruit.type.size * 120; 

            const dist = Math.hypot(state.fingerPos.x - fruitX, state.fingerPos.y - fruitY);
            if (dist < hitRadius) {
                fruit.slice(cutDir);
            }
        });
    }
    state.lastFingerPos.copy(state.fingerPos);
}

// ================= AI =================
function onResults(results) {
    if (loadingText.style.display !== 'none') {
        loadingText.style.display = 'none';
        startBtn.style.display = 'block';
    }
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        state.hasHand = true;
        const lm = results.multiHandLandmarks[0][8]; 
        state.fingerPos.set((1 - lm.x) * window.innerWidth, lm.y * window.innerHeight);
    } else {
        state.hasHand = false;
    }
}

const hands = new Hands({locateFile: f => `https://unpkg.com/@mediapipe/hands@0.4.1646424915/${f}`});
hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
hands.onResults(onResults);

const cam = new Camera(document.getElementById('input_video'), { 
    onFrame: async () => await hands.send({image: document.getElementById('input_video')}), 
    width: 640, height: 480 
});
cam.start();

// ================= Audio =================
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playAudio(type) {
    if(audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain); gain.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    if (type === 'slice') {
        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(1000, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
        gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.1);
        osc.start(now); osc.stop(now + 0.1);
    }
}

startBtn.onclick = () => {
    audioCtx.resume();
    overlay.style.opacity = 0;
    setTimeout(() => overlay.style.display = 'none', 300);
    resetGame();
    state.isPlaying = true;
};
restartBtn.onclick = () => {
    overlay.style.display = 'flex'; overlay.style.opacity = 1;
    document.getElementById('game-over-content').style.display = 'none';
    startBtn.style.display = 'block';
    document.getElementById('overlay-title').innerText = "AR 水果忍者";
    startBtn.click();
};

function animate() {
    requestAnimationFrame(animate);
    updateInputAndCheckSlice();
    if (state.isPlaying && !state.isGameOver) updateFruits();
    renderer.render(scene, camera);
}
animate();
window.onresize = () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };
</script>
</body>
</html>
