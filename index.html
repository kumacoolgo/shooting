<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>AR 射击：必中修复版</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; height: 100dvh; width: 100vw; touch-action: none; font-family: 'Arial', sans-serif; }
        #input_video { position: absolute; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); z-index: 0; opacity: 0.6; }
        #output_canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; }
        .score-board { position: absolute; top: 30px; left: 20px; color: #00ffcc; font-size: 28px; font-weight: 900; text-shadow: 0 0 10px #00ffcc; font-family: monospace; }
        .float-text { position: absolute; font-weight: 900; font-size: 24px; animation: floatUp 0.6s ease-out forwards; text-shadow: 2px 2px 0px #000; z-index: 10; }
        @keyframes floatUp { 0% { opacity: 1; transform: translateY(0) scale(0.8); } 100% { opacity: 0; transform: translateY(-50px) scale(1.2); } }
        
        /* 遮罩 */
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #111; z-index: 999; display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; transition: opacity 0.5s; }
        .spinner { width: 40px; height: 40px; border: 4px solid #333; border-top: 4px solid #00ffcc; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #start-btn { display: none; padding: 15px 50px; background: #00ffcc; color: #000; font-size: 20px; font-weight: bold; border: none; border-radius: 30px; animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils@0.3.1640029074/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils@0.6.1629159505/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils@0.3.1620248257/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <div id="overlay">
        <div class="spinner" id="spinner"></div>
        <div id="loading-text">正在初始化 AI...</div>
        <button id="start-btn">点击开始</button>
    </div>
    <video id="input_video" playsinline webkit-playsinline></video>
    <canvas id="output_canvas"></canvas>
    <div id="hud"><div class="score-board">SCORE: <span id="score">0</span></div></div>

<script>
const config = { baseSpeed: 0.02, aimRadius: 0.15, triggerDist: 0.06 };
let state = { score: 0, isPlaying: false, handDetected: false, triggerState: 'open', fingerPos: new THREE.Vector2(), lockedEnemy: null };

// DOM
const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('start-btn');
const scoreEl = document.getElementById('score');

// Three.js
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.z = 5;
const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('output_canvas'), alpha: true, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

scene.add(new THREE.AmbientLight(0xffffff, 0.8));
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(2, 5, 5);
scene.add(light);

// 资源
const enemies = [];
let laserLine, reticle;
const raycaster = new THREE.Raycaster();

function initVisuals() {
    // 准心
    const rGeo = new THREE.RingGeometry(0.12, 0.15, 32);
    const mat = new THREE.MeshBasicMaterial({ color: 0x00ffcc, transparent: true, opacity: 0.8 });
    reticle = new THREE.Group();
    reticle.add(new THREE.Mesh(rGeo, mat));
    reticle.add(new THREE.Mesh(new THREE.CircleGeometry(0.02, 16), mat.clone()));
    reticle.visible = false;
    scene.add(reticle);

    // 激光
    const lGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3(0,0,-10)]);
    laserLine = new THREE.Line(lGeo, new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 2, transparent: true, opacity: 0.6 }));
    laserLine.visible = false;
    scene.add(laserLine);
}
initVisuals();

// 游戏逻辑
const enemyGeo = new THREE.OctahedronGeometry(0.5);
const enemyMat = new THREE.MeshPhongMaterial({ color: 0xff3333 });

function spawnEnemy() {
    if(enemies.length >= 4) return;
    const e = new THREE.Mesh(enemyGeo, enemyMat.clone());
    const angle = Math.random() * Math.PI * 2;
    e.position.set(Math.cos(angle)*6, Math.sin(angle)*6, 0);
    e.userData.velocity = e.position.clone().normalize().multiplyScalar(-config.baseSpeed * (1 + state.score/200));
    scene.add(e);
    enemies.push(e);
}

// 核心修复：射击判定
function fireShot(origin) {
    if(!state.isPlaying) return;
    playAudio('laser');
    
    // 激光特效
    laserLine.geometry.setFromPoints([
        new THREE.Vector3(origin.x + 0.3, origin.y - 0.5, 4), // 右手模拟位置
        new THREE.Vector3(origin.x, origin.y, -5) // 射向远处
    ]);
    laserLine.visible = true;
    setTimeout(() => laserLine.visible = false, 80);

    let hitObj = null;

    // 1. 优先判定：是否有“磁吸锁定”的敌人 (必中逻辑)
    if (state.lockedEnemy) {
        hitObj = state.lockedEnemy;
    } 
    // 2. 备用判定：如果没有锁定，才用射线检测 (盲射)
    else {
        raycaster.setFromCamera(state.fingerPos, camera);
        const intersects = raycaster.intersectObjects(enemies);
        if (intersects.length > 0) hitObj = intersects[0].object;
    }

    if (hitObj) {
        playAudio('explosion');
        showFloatingText("HIT!", hitObj.position);
        
        // 移除敌人
        scene.remove(hitObj);
        enemies.splice(enemies.indexOf(hitObj), 1);
        
        state.score += 10;
        scoreEl.innerText = state.score;
        spawnEnemy();
    }
}

// AI 循环
function onResults(results) {
    if (overlay.style.display !== 'none' && !startBtn.style.display) {
        document.getElementById('spinner').style.display = 'none';
        document.getElementById('loading-text').innerText = "AI 就绪";
        startBtn.style.display = 'block';
    }
    
    if(!state.isPlaying) return;

    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        state.handDetected = true;
        const lm = results.multiHandLandmarks[0];
        
        // 坐标计算
        const idx = lm[8]; // 食指
        const ndcX = (1 - idx.x) * 2 - 1;
        const ndcY = (1 - idx.y) * 2 - 1; // 修正Y轴翻转问题

        // 磁吸寻找最近敌人
        let targetX = ndcX, targetY = ndcY;
        let minD = config.aimRadius;
        state.lockedEnemy = null; // 重置锁定状态

        enemies.forEach(e => {
            const sPos = e.position.clone().project(camera);
            const d = Math.sqrt((sPos.x - ndcX)**2 + (sPos.y - ndcY)**2);
            if(d < minD) {
                minD = d;
                targetX = sPos.x;
                targetY = sPos.y;
                state.lockedEnemy = e; // 【关键】保存被锁定的敌人对象
            }
        });

        // 准心平滑
        state.fingerPos.x += (targetX - state.fingerPos.x) * 0.5;
        state.fingerPos.y += (targetY - state.fingerPos.y) * 0.5;

        // 更新 3D 准心
        const v = new THREE.Vector3(state.fingerPos.x, state.fingerPos.y, 0.5);
        v.unproject(camera);
        const dir = v.sub(camera.position).normalize();
        const pos = camera.position.clone().add(dir.multiplyScalar(4));
        reticle.position.copy(pos);
        reticle.lookAt(camera.position);
        reticle.visible = true;

        // 颜色反馈
        reticle.children[0].material.color.setHex(state.lockedEnemy ? 0xff0000 : 0x00ffcc);

        // 触发逻辑
        const dist = Math.hypot(lm[4].x - lm[5].x, lm[4].y - lm[5].y);
        if (dist < config.triggerDist) {
            if (state.triggerState === 'open') {
                state.triggerState = 'closed';
                reticle.scale.set(1.5, 1.5, 1.5);
                fireShot(pos);
            }
        } else if (dist > config.triggerDist * 1.4) {
            state.triggerState = 'open';
            reticle.scale.set(1, 1, 1);
        }
    } else {
        reticle.visible = false;
        state.lockedEnemy = null;
    }
}

// MediaPipe Setup
const hands = new Hands({locateFile: f => `https://unpkg.com/@mediapipe/hands@0.4.1646424915/${f}`});
hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
hands.onResults(onResults);
const cam = new Camera(document.getElementById('input_video'), { onFrame: async () => await hands.send({image: document.getElementById('input_video')}), width: 640, height: 480 }); // 降分辨率提速
cam.start();

// 辅助
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playAudio(type) {
    if(audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    if(type === 'laser') {
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(100, now+0.1);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now+0.1);
        osc.start(now); osc.stop(now+0.1);
    } else {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.exponentialRampToValueAtTime(10, now+0.2);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.linearRampToValueAtTime(0, now+0.2);
        osc.start(now); osc.stop(now+0.2);
    }
}

function showFloatingText(text, pos) {
    const div = document.createElement('div');
    div.innerText = text;
    div.className = 'float-text';
    div.style.color = '#00ffcc';
    
    // 正确的 3D -> 2D 转换
    const tempV = pos.clone().project(camera);
    const x = (tempV.x * .5 + .5) * window.innerWidth;
    const y = (-(tempV.y * .5) + .5) * window.innerHeight;
    
    div.style.left = x + 'px';
    div.style.top = y + 'px';
    document.getElementById('hud').appendChild(div);
    setTimeout(() => div.remove(), 600);
}

startBtn.onclick = () => {
    audioCtx.resume();
    overlay.style.opacity = 0;
    setTimeout(() => overlay.style.display='none', 500);
    state.isPlaying = true;
    spawnEnemy(); spawnEnemy();
};

function animate() {
    requestAnimationFrame(animate);
    if(state.isPlaying) {
        for(let i=enemies.length-1; i>=0; i--) {
            enemies[i].position.add(enemies[i].userData.velocity);
            enemies[i].rotation.x += 0.05; enemies[i].rotation.z += 0.05;
            if(enemies[i].position.length() < 1) { // 撞脸扣分
                scene.remove(enemies[i]); enemies.splice(i,1);
                state.score = Math.max(0, state.score-5); scoreEl.innerText = state.score;
            }
        }
        if(Math.random()<0.03) spawnEnemy();
    }
    renderer.render(scene, camera);
}
animate();
window.onresize = () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };
</script>
</body>
</html>
