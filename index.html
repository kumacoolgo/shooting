<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D åœ£è¯äº¤äº’ç²’å­ç³»ç»Ÿ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050510; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: none;
        }
        .control-btn {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 12px 24px;
            border-radius: 30px;
            cursor: pointer;
            font-size: 14px;
            pointer-events: auto;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: fit-content;
        }
        .control-btn:hover { background: rgba(255, 255, 255, 0.25); box-shadow: 0 0 15px rgba(255, 255, 255, 0.3); }
        #camera-feed {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 12px;
            transform: scaleX(-1);
            opacity: 0.7;
            border: 2px solid rgba(255,255,255,0.3);
            z-index: 5;
            object-fit: cover;
        }
        #file-input { display: none; }
        .instruction {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            text-align: center;
            pointer-events: none;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="loading">æ­£åœ¨åˆå§‹åŒ–è§†è§‰å¼•æ“ä¸æ‘„åƒå¤´...</div>

    <div id="ui-container">
        <button class="control-btn" id="upload-btn">ğŸ æ’å…¥ç…§ç‰‡</button>
        <button class="control-btn" id="fullscreen-btn">â›¶ å…¨å±æ¨¡å¼</button>
        <input type="file" id="file-input" accept="image/*" multiple>
    </div>

    <div class="instruction">
        ğŸ– å¼ å¼€: æ—‹è½¬æ•£å¼€ | âœŠ æ¡æ‹³: èšåˆæˆæ ‘ | ğŸ‘Œ æåˆ: æŠ“å–ç…§ç‰‡
    </div>

    <video id="camera-feed" playsinline muted autoplay></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        // --- 1. åˆå§‹åŒ– Three.js åœºæ™¯ ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050510, 0.002);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;
        camera.position.y = 10;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // ç§»åŠ¨ç«¯ä¼˜åŒ–
        document.body.appendChild(renderer.domElement);

        // ç¯å…‰
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);

        // æ ‘é¡¶ç¯æ³¡ (ç‚¹å…‰æº)
        const topperLight = new THREE.PointLight(0xffaa00, 2, 50);
        topperLight.position.set(0, 22, 0);
        scene.add(topperLight);
        
        // æ ‘é¡¶è£…é¥°
        const topperGeo = new THREE.SphereGeometry(1, 32, 32);
        const topperMat = new THREE.MeshStandardMaterial({ 
            color: 0xffdd00, 
            emissive: 0xffaa00,
            emissiveIntensity: 1,
            roughness: 0.2,
            metalness: 0.8
        });
        const topperMesh = new THREE.Mesh(topperGeo, topperMat);
        topperMesh.position.set(0, 22, 0);
        scene.add(topperMesh);

        // --- 2. ç²’å­ç³»ç»Ÿæ ¸å¿ƒé€»è¾‘ ---
        
        const particleCount = 2500; // ç²’å­æ•°é‡ï¼Œç§»åŠ¨ç«¯é€‚ä¸­
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const targets = []; // æ ‘çš„ç›®æ ‡ä½ç½®
        const randoms = []; // ç”¨äºæ•£å¼€æ—¶çš„éšæœºä½ç½®
        const sizes = [];
        const colors = [];
        const types = []; // 0: sphere, 1: gift, 2: sock, 3: bell, 4: tie, 5: tree, 6: santa

        // é¢„å®šä¹‰é¢œè‰²å’Œ Emoji
        const palette = [0xff0000, 0x00ff00, 0xffd700, 0xffffff, 0x00bfff];
        const emojis = ['ğŸ', 'ğŸ””', 'ğŸ‘”', 'ğŸ…', 'ğŸ„', 'â­', 'â„ï¸'];

        // ç”Ÿæˆçº¹ç†å›¾é›† (Texture Atlas) - ç”¨ Canvas ç”» Emoji
        function createEmojiTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.font = '60px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // å°† Emoji ç”»åœ¨ç½‘æ ¼ä¸Šï¼Œç„¶ååœ¨ Shader ä¸­é€šè¿‡ UV åç§»é€‰æ‹©
            // è¿™é‡Œä¸ºäº†ç®€åŒ– Shaderï¼Œæˆ‘ä»¬ç›´æ¥ç”Ÿæˆå•ä¸€çº¹ç†ï¼Œåç»­è‹¥éœ€ä¸åŒ Emoji æœ€å¥½ç”¨ SpriteSheet
            // ä¸ºäº†æ¼”ç¤ºæ•ˆæœï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªåŒ…å«æ··åˆå›¾æ¡ˆçš„çº¹ç†
            emojis.forEach((emoji) => {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                ctx.fillStyle = 'white';
                ctx.fillText(emoji, x, y);
            });
            
            // ç»˜åˆ¶ä¸€äº›åŸºæœ¬å›¾å½¢
            for(let i=0; i<20; i++) {
                ctx.beginPath();
                ctx.arc(Math.random()*512, Math.random()*512, 10, 0, Math.PI*2);
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.fill();
            }

            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }
        
        const particleTexture = createEmojiTexture();

        // æ„å»ºåœ£è¯æ ‘å½¢çŠ¶ (èºæ—‹åœ†é”¥)
        for (let i = 0; i < particleCount; i++) {
            // éšæœºåˆ†å¸ƒ (æ•£å¼€çŠ¶æ€)
            const rx = (Math.random() - 0.5) * 60;
            const ry = (Math.random() - 0.5) * 60;
            const rz = (Math.random() - 0.5) * 60;
            positions.push(rx, ry, rz);
            randoms.push(rx, ry, rz);

            // æ ‘å½¢åˆ†å¸ƒ (ç›®æ ‡çŠ¶æ€)
            const angle = i * 0.15; // èºæ—‹å¯†åº¦
            const height = 20 - (i / particleCount) * 20; // é«˜åº¦ 20 åˆ° 0
            const radius = (20 - height) * 0.4 + Math.random(); // åº•éƒ¨å®½é¡¶éƒ¨çª„
            const tx = Math.cos(angle) * radius;
            const ty = height;
            const tz = Math.sin(angle) * radius;
            targets.push(tx, ty, tz);

            sizes.push(Math.random() * 0.5 + 0.5);
            
            const color = new THREE.Color(palette[Math.floor(Math.random() * palette.length)]);
            colors.push(color.r, color.g, color.b);
            
            types.push(Math.floor(Math.random() * 7));
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('target', new THREE.Float32BufferAttribute(targets, 3));
        geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

        // è‡ªå®šä¹‰ç€è‰²å™¨ - å®ç°æè‡´ä¸æ»‘çš„å˜å½¢å’Œå…‰ç…§
        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uMix: { value: 0 }, // 0: æ•£å¼€, 1: æ ‘
                uTexture: { value: particleTexture },
                uScale: { value: 1.0 },
                uLightPos: { value: new THREE.Vector3(0, 22, 0) }
            },
            vertexShader: `
                uniform float uTime;
                uniform float uMix;
                uniform float uScale;
                uniform vec3 uLightPos;
                
                attribute vec3 target;
                attribute vec3 aRandom;
                attribute vec3 color;
                attribute float size;
                
                varying vec3 vColor;
                varying float vAlpha;
                varying float vDistToLight;

                // ç®€å•çš„å™ªå£°å‡½æ•°ï¼Œè®©æ•£å¼€æ—¶æœ‰é£˜åŠ¨æ„Ÿ
                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }

                void main() {
                    vColor = color;
                    
                    // æ··åˆä½ç½®
                    vec3 pos = mix(aRandom, target, uMix);
                    
                    // æ•£å¼€æ—¶æ·»åŠ æ—‹è½¬å’Œæ³¢åŠ¨
                    if(uMix < 0.8) {
                        float angle = uTime * 0.5;
                        float c = cos(angle);
                        float s = sin(angle);
                        mat3 rot = mat3(c, 0, s, 0, 1, 0, -s, 0, c);
                        pos = rot * pos;
                        
                        pos.y += sin(uTime + pos.x) * 0.5;
                    }

                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    
                    // ç²’å­å¤§å°éšè·ç¦»å˜åŒ–ï¼Œä¸”å—æ‰‹åŠ¿ç¼©æ”¾å½±å“
                    gl_PointSize = size * (300.0 / -mvPosition.z) * uScale;
                    
                    // è®¡ç®—å…‰ç…§åå…‰
                    float dist = distance(pos, uLightPos);
                    vDistToLight = 1.0 - smoothstep(0.0, 30.0, dist);

                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform sampler2D uTexture;
                varying vec3 vColor;
                varying float vDistToLight;

                void main() {
                    // åœ†å½¢è£å‰ª
                    vec2 uv = gl_PointCoord;
                    float dist = distance(uv, vec2(0.5));
                    if (dist > 0.5) discard;
                    
                    vec4 texColor = texture2D(uTexture, uv);
                    
                    // åŸºç¡€é¢œè‰² + ç¯å…‰è¾‰å…‰ (åå…‰æ•ˆæœ)
                    vec3 finalColor = vColor + vec3(0.8, 0.8, 0.6) * vDistToLight * 0.8;
                    
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        // --- 3. ç…§ç‰‡ç³»ç»Ÿ (Sprite) ---
        const photoGroup = new THREE.Group();
        scene.add(photoGroup);
        const uploadedPhotos = [];

        function addPhotoToTree(texture) {
            const spriteMat = new THREE.SpriteMaterial({ 
                map: texture, 
                color: 0xffffff,
                transparent: true
            });
            const sprite = new THREE.Sprite(spriteMat);
            
            // éšæœºæ”¾ç½®åœ¨æ ‘çš„èŒƒå›´å†…
            const height = Math.random() * 18;
            const angle = Math.random() * Math.PI * 2;
            const radius = (20 - height) * 0.4 * 0.8; // ç¨å¾®åœ¨å†…éƒ¨ä¸€ç‚¹
            
            sprite.position.set(
                Math.cos(angle) * radius,
                height,
                Math.sin(angle) * radius
            );
            
            // åˆå§‹å¤§å°å’Œç²’å­å·®ä¸å¤š
            sprite.scale.set(1.5, 1.5, 1.5);
            
            // ä¿å­˜åŸå§‹ä½ç½®ä»¥ä¾¿å¤åŸ
            sprite.userData = { 
                originalPos: sprite.position.clone(),
                originalScale: new THREE.Vector3(1.5, 1.5, 1.5),
                isFocused: false 
            };
            
            photoGroup.add(sprite);
            uploadedPhotos.push(sprite);
        }

        // --- 4. äº¤äº’é€»è¾‘ (MediaPipe Hands) ---
        
        let targetMix = 0; // 0 = æ•£å¼€, 1 = æ ‘
        let targetScale = 1;
        let isPinching = false;
        let pinchTimer = 0;

        const videoElement = document.getElementById('camera-feed');
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // å¯åŠ¨æ‘„åƒå¤´
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320,
            height: 240
        });
        cameraUtils.start().then(() => {
            document.getElementById('loading').style.display = 'none';
        });

        function calculateDistance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        // çŠ¶æ€å¹³æ»‘è¿‡æ¸¡å˜é‡
        const smoothState = { mix: 0, scale: 1, rotY: 0 };

        function onResults(results) {
            let gestureDetected = 'OPEN'; // DEFAULT
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. æ£€æµ‹æ¡æ‹³ (Fist): æŒ‡å°–é è¿‘æŒå¿ƒ
                // ç®€å•åˆ¤å®šï¼šé£ŸæŒ‡æŒ‡å°–(8) åˆ° æŒå¿ƒ(0) çš„è·ç¦» < é£ŸæŒ‡æ ¹éƒ¨(5) åˆ° æŒå¿ƒ(0)
                const palmBase = landmarks[0];
                const indexTip = landmarks[8];
                const indexBase = landmarks[5];
                
                const tipDist = calculateDistance(indexTip, palmBase);
                const baseDist = calculateDistance(indexBase, palmBase);
                
                // 2. æ£€æµ‹æåˆ (Pinch): æ‹‡æŒ‡å°–(4) å’Œ é£ŸæŒ‡å°–(8) è·ç¦»æè¿‘
                const thumbTip = landmarks[4];
                const pinchDist = calculateDistance(thumbTip, indexTip);
                
                if (pinchDist < 0.05) {
                    gestureDetected = 'PINCH';
                } else if (tipDist < baseDist * 0.8) { // ç®€å•æ¡æ‹³åˆ¤å®š
                    gestureDetected = 'FIST';
                } else {
                    gestureDetected = 'OPEN';
                }

                // è®¡ç®—åŒæ‰‹è·ç¦»ç”¨äºç¼©æ”¾ (å¦‚æœæ£€æµ‹åˆ°ä¸¤åªæ‰‹)
                if (results.multiHandLandmarks.length === 2) {
                    const hand1 = results.multiHandLandmarks[0][0];
                    const hand2 = results.multiHandLandmarks[1][0];
                    const dist = calculateDistance(hand1, hand2);
                    // æ˜ å°„è·ç¦» 0.2-0.8 åˆ° ç¼©æ”¾ 0.5-2.0
                    targetScale = Math.max(0.5, Math.min(2.5, dist * 3));
                }
            } else {
                // æ— æ‰‹åŠ¿ï¼Œé»˜è®¤è‡ªåŠ¨æ—‹è½¬
                gestureDetected = 'IDLE';
            }

            // çŠ¶æ€é€»è¾‘å¤„ç†
            if (gestureDetected === 'FIST') {
                targetMix = 1; // èšåˆæˆæ ‘
                isPinching = false;
            } else if (gestureDetected === 'OPEN') {
                targetMix = 0; // æ•£å¼€
                isPinching = false;
                // å¤åŸç…§ç‰‡
                resetPhotos();
            } else if (gestureDetected === 'PINCH') {
                targetMix = 0; // æåˆæ—¶ä¿æŒæ•£å¼€çŠ¶æ€ (ç”¨æˆ·è¦æ±‚ï¼šæåˆæ—¶ç²’å­å¤„äºæ•£å¼€çš„çŠ¶æ€ä¿æŒä¸å˜)
                // ä½†è¿™é‡Œæœ‰ç‚¹å†²çªï¼Œå¦‚æœ"æ•£å¼€ç”¨ç²’å­ç»„æˆçš„åœ£è¯æ ‘"æ˜¯æŒ‡ä¿æŒæ ‘å½¢ä½†æ¾æ•£ï¼Ÿ
                // è®©æˆ‘ä»¬ç†è§£ä¸ºï¼šæåˆæ—¶ï¼Œæˆ‘ä»¬å…³æ³¨ç…§ç‰‡ï¼ŒèƒŒæ™¯ä¿æŒå½“å‰çŠ¶æ€ã€‚
                // è§¦å‘ç…§ç‰‡æŠ“å–
                if (!isPinching) {
                    isPinching = true;
                    focusRandomPhoto();
                }
            }
        }

        // --- 5. åŠ¨ç”»ä¸è¿‡æ¸¡ç‰¹æ•ˆ (GSAP & Loop) ---

        let activePhoto = null;

        function focusRandomPhoto() {
            if (uploadedPhotos.length === 0) return;
            if (activePhoto) return; // å·²ç»æœ‰ç…§ç‰‡åœ¨å±•ç¤ºä¸­

            // éšæœºé€‰ä¸€å¼ 
            const index = Math.floor(Math.random() * uploadedPhotos.length);
            activePhoto = uploadedPhotos[index];
            activePhoto.userData.isFocused = true;

            // GSAP ä¸æ»‘å…¥åœºåŠ¨ç”»
            // 1. ç§»åŠ¨åˆ°ç›¸æœºå‰æ–¹
            // 2. æ”¾å¤§
            // 3. æ·»åŠ å…‰æ™• (é€šè¿‡ Scale æ¨¡æ‹Ÿæˆ– Shader)
            
            // è®¡ç®—ç›¸æœºå‰æ–¹çš„ä½ç½®
            const vector = new THREE.Vector3(0, 0, -10);
            vector.applyQuaternion(camera.quaternion);
            const targetPos = camera.position.clone().add(vector);
            targetPos.y -= 2; // ç¨å¾®è°ƒæ•´é«˜åº¦

            // ä¸åŒçš„è¿‡æ¸¡ç‰¹æ•ˆ (ç®€å•æ¨¡æ‹Ÿï¼šæ—‹è½¬å…¥åœº æˆ– å¼¹æ€§å…¥åœº)
            const effectType = Math.random() > 0.5 ? 'elastic' : 'rotate';

            if (effectType === 'elastic') {
                gsap.to(activePhoto.position, {
                    x: targetPos.x, y: targetPos.y, z: targetPos.z,
                    duration: 1.5, ease: "elastic.out(1, 0.5)"
                });
            } else {
                gsap.to(activePhoto.position, {
                    x: targetPos.x, y: targetPos.y, z: targetPos.z,
                    duration: 1.2, ease: "power3.out"
                });
                // æ—‹è½¬ä¸€åœˆ
                gsap.fromTo(activePhoto.material, { rotation: 0 }, { rotation: Math.PI * 2, duration: 1 });
            }

            // æ”¾å¤§å¹¶æ·»åŠ è¾‰å…‰æ•ˆæœ (è¿™é‡Œç®€åŒ–ä¸ºæ”¾å¤§)
            gsap.to(activePhoto.scale, {
                x: 8, y: 8, z: 8,
                duration: 1,
                ease: "power2.out"
            });
        }

        function resetPhotos() {
            if (!activePhoto) return;
            
            // å¤åŸ
            gsap.to(activePhoto.position, {
                x: activePhoto.userData.originalPos.x,
                y: activePhoto.userData.originalPos.y,
                z: activePhoto.userData.originalPos.z,
                duration: 0.8,
                ease: "power2.inOut"
            });
            gsap.to(activePhoto.scale, {
                x: activePhoto.userData.originalScale.x,
                y: activePhoto.userData.originalScale.y,
                z: activePhoto.userData.originalScale.z,
                duration: 0.8,
                onComplete: () => {
                    activePhoto.userData.isFocused = false;
                    activePhoto = null;
                }
            });
        }

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            // å¹³æ»‘æ··åˆ uniform
            smoothState.mix += (targetMix - smoothState.mix) * 5 * dt;
            smoothState.scale += (targetScale - smoothState.scale) * 3 * dt;

            // æ›´æ–° Shader Uniforms
            material.uniforms.uTime.value = time;
            material.uniforms.uMix.value = smoothState.mix;
            material.uniforms.uScale.value = smoothState.scale;

            // æ—‹è½¬é€»è¾‘ï¼šæ•£å¼€æ—¶æ—‹è½¬ï¼Œèšåˆæ—¶æ…¢æ…¢å¯¹é½
            if (smoothState.mix < 0.5) {
                // æ•£å¼€æ—‹è½¬
                particleSystem.rotation.y += 0.2 * dt;
                photoGroup.rotation.y += 0.2 * dt;
            } else {
                // èšåˆæ—¶ç¼“æ…¢å¤ä½æˆ–è½»å¾®æ‘†åŠ¨
                particleSystem.rotation.y += (0 - particleSystem.rotation.y) * 0.1 * dt;
                photoGroup.rotation.y += (0 - photoGroup.rotation.y) * 0.1 * dt;
            }

            // æ›´æ–°ç…§ç‰‡ç»„ä½ç½® (è·Ÿéšç²’å­æ ‘ç¼©æ”¾)
            // ç®€å•å¤„ç†ï¼šå½“æ ‘å˜å¤§å˜å°æ—¶ï¼Œç…§ç‰‡ç»„æ•´ä½“ä¹Ÿå¯ä»¥ç¼©æ”¾ï¼Œä½†æˆ‘ä»¬å·²åœ¨ shader ä¸­ç¼©æ”¾ç²’å­
            // è¿™é‡Œæˆ‘ä»¬æ‰‹åŠ¨ç¼©æ”¾ photoGroup
            photoGroup.scale.setScalar(smoothState.scale);

            // è®©ç…§ç‰‡é¢å‘ç›¸æœº
            uploadedPhotos.forEach(p => {
                // å¦‚æœæ˜¯è¢«æŠ“å–çš„ç…§ç‰‡ï¼Œä¸éœ€è¦ä¸€ç›´åœ¨æ­¤å¤„è®¾ rotationï¼Œå› ä¸º GSAP å¯èƒ½åœ¨æ§åˆ¶
                // ä½† SpriteMaterial é»˜è®¤å°±æ˜¯é¢å‘ç›¸æœºçš„ï¼Œæ‰€ä»¥åªéœ€å¤„ç†ä½ç½®
            });

            renderer.render(scene, camera);
        }

        animate();

        // --- 6. UI äº‹ä»¶å¤„ç† ---

        document.getElementById('upload-btn').addEventListener('click', () => {
            document.getElementById('file-input').click();
        });

        document.getElementById('file-input').addEventListener('change', (e) => {
            const files = e.target.files;
            if (files.length > 0) {
                for (let i = 0; i < files.length; i++) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        const img = new Image();
                        img.src = event.target.result;
                        img.onload = () => {
                            const texture = new THREE.Texture(img);
                            texture.needsUpdate = true;
                            addPhotoToTree(texture);
                        }
                    }
                    reader.readAsDataURL(files[i]);
                }
            }
        });

        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        });

    </script>
</body>
</html>
